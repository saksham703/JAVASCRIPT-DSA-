function hasCycle(graph) {
  const n = graph.length;
  const visited = new Array(n).fill(false);
  const pathVisited = new Array(n).fill(false);

  function dfs(node) {
    visited[node] = true;
    pathVisited[node] = true;

    for (const neighbor of graph[node]) {
      if (!visited[neighbor]) {
        if (dfs(neighbor)) {
          return true;
        }
      }
// If node is already visited & pathVisited is also true
else if (pathVisited[neighbor]) {
        return true;
      }
    }

    pathVisited[node] = false; // Backtrack
    return false;
  }

// for all disconnected graph components
  for (let i = 0; i < n; i++) {
    if (!visited[i]) {
      if (dfs(i)) {
        return true;
      }
    }
  }

  return false;
}

// Example usage:
// Graph represented as adjacency list
const graph = [
  [1],    // Node 0 -> Node 1
  [2],    // Node 1 -> Node 2
  [0],    // Node 2 -> Node 0 (cycle here)
  [4],    // Node 3 -> Node 4
  []      // Node 4 -> no edges
];

console.log(hasCycle(graph));  // Output: true




// Using Topological Sort - DFS






// Using Topological Sort - KHAN'S ALGORITHM - BFS


function hasCycle(graph) {
  const n = graph.length;
  const inDegree = new Array(n).fill(0);

  for (let u = 0; u < n; u++) {
    for (const v of graph[u]) {
      inDegree[v]++;
    }
  }

  const queue = [];
  for (let i = 0; i < n; i++) {
    if (inDegree[i] === 0) {
      queue.push(i);
    }
  }

  let count = 0;

  while (queue.length > 0) {
    const u = queue.shift();
    count++;   //  topoSort.push(u); 

    for (const v of graph[u]) {
      inDegree[v]--;
      if (inDegree[v] === 0) {
        queue.push(v);
      }
    }
  }

  // If count doesnâ€™t match number of nodes, cycle exists
  return count !== n;  // (or topoSort.length == n);
}

// Example usage:
const graph = [
  [1],     // 0 -> 1
  [2],     // 1 -> 2
  [0, 3],  // 2 -> 0 (cycle here) and 2 -> 3
  []       // 3 -> no outgoing edges
];

console.log(hasCycle(graph)); // Output: true (because of cycle 0 -> 1 -> 2 -> 0)
